'use strict';var cov_ygobsuc9c=function(){var path='internal/inspector_async_hook.js',hash='0286da5a765b57e60f1c84af2945f517d58aa5de',global=new Function('return this')(),gcv='__coverage__',coverageData={path:'internal/inspector_async_hook.js',statementMap:{'0':{start:{line:3,column:23},end:{line:3,column:45}},'1':{start:{line:4,column:18},end:{line:4,column:46}},'2':{start:{line:5,column:15},end:{line:5,column:40}},'3':{start:{line:7,column:0},end:{line:10,column:1}},'4':{start:{line:8,column:2},end:{line:8,column:32}},'5':{start:{line:9,column:2},end:{line:9,column:9}},'6':{start:{line:12,column:13},end:{line:33,column:2}},'7':{start:{line:18,column:22},end:{line:18,column:26}},'8':{start:{line:19,column:4},end:{line:19,column:59}},'9':{start:{line:23,column:4},end:{line:23,column:40}},'10':{start:{line:27,column:4},end:{line:27,column:41}},'11':{start:{line:31,column:4},end:{line:31,column:41}},'12':{start:{line:36,column:2},end:{line:49,column:3}},'13':{start:{line:41,column:4},end:{line:46,column:9}},'14':{start:{line:48,column:4},end:{line:48,column:18}},'15':{start:{line:53,column:2},end:{line:53,column:17}},'16':{start:{line:56,column:0},end:{line:64,column:2}},'17':{start:{line:57,column:2},end:{line:57,column:47}},'18':{start:{line:59,column:2},end:{line:63,column:3}},'19':{start:{line:62,column:4},end:{line:62,column:13}}},fnMap:{'0':{name:'(anonymous_0)',decl:{start:{line:8,column:18},end:{line:8,column:19}},loc:{start:{line:8,column:29},end:{line:8,column:31}},line:8},'1':{name:'enable',decl:{start:{line:35,column:9},end:{line:35,column:15}},loc:{start:{line:35,column:18},end:{line:50,column:1}},line:35},'2':{name:'disable',decl:{start:{line:52,column:9},end:{line:52,column:16}},loc:{start:{line:52,column:19},end:{line:54,column:1}},line:52},'3':{name:'(anonymous_3)',decl:{start:{line:56,column:16},end:{line:56,column:17}},loc:{start:{line:56,column:27},end:{line:64,column:1}},line:56}},branchMap:{'0':{loc:{start:{line:7,column:0},end:{line:10,column:1}},type:'if',locations:[{start:{line:7,column:0},end:{line:10,column:1}},{start:{line:7,column:0},end:{line:10,column:1}}],line:7},'1':{loc:{start:{line:7,column:4},end:{line:7,column:47}},type:'binary-expr',locations:[{start:{line:7,column:4},end:{line:7,column:14}},{start:{line:7,column:18},end:{line:7,column:47}}],line:7},'2':{loc:{start:{line:36,column:2},end:{line:49,column:3}},type:'if',locations:[{start:{line:36,column:2},end:{line:49,column:3}},{start:{line:36,column:2},end:{line:49,column:3}}],line:36},'3':{loc:{start:{line:59,column:2},end:{line:63,column:3}},type:'if',locations:[{start:{line:59,column:2},end:{line:63,column:3}},{start:{line:59,column:2},end:{line:63,column:3}}],line:59}},s:{'0':0,'1':0,'2':0,'3':0,'4':0,'5':0,'6':0,'7':0,'8':0,'9':0,'10':0,'11':0,'12':0,'13':0,'14':0,'15':0,'16':0,'17':0,'18':0,'19':0},f:{'0':0,'1':0,'2':0,'3':0},b:{'0':[0,0],'1':[0,0],'2':[0,0],'3':[0,0]},_coverageSchema:'332fd63041d2c1bcb487cc26dd0d5f7d97098a6c'},coverage=global[gcv]||(global[gcv]={});if(coverage[path]&&coverage[path].hash===hash){return coverage[path];}coverageData.hash=hash;return coverage[path]=coverageData;}();const{createHook}=(cov_ygobsuc9c.s[0]++,require('async_hooks'));const inspector=(cov_ygobsuc9c.s[1]++,process.binding('inspector'));const config=(cov_ygobsuc9c.s[2]++,process.binding('config'));cov_ygobsuc9c.s[3]++;if((cov_ygobsuc9c.b[1][0]++,!inspector)||(cov_ygobsuc9c.b[1][1]++,!inspector.asyncTaskScheduled)){cov_ygobsuc9c.b[0][0]++;cov_ygobsuc9c.s[4]++;exports.setup=function(){cov_ygobsuc9c.f[0]++;};cov_ygobsuc9c.s[5]++;return;}else{cov_ygobsuc9c.b[0][1]++;}const hook=(cov_ygobsuc9c.s[6]++,createHook({init(asyncId,type,triggerAsyncId,resource){// It's difficult to tell which tasks will be recurring and which won't,
// therefore we mark all tasks as recurring. Based on the discussion
// in https://github.com/nodejs/node/pull/13870#discussion_r124515293,
// this should be fine as long as we call asyncTaskCanceled() too.
const recurring=(cov_ygobsuc9c.s[7]++,true);cov_ygobsuc9c.s[8]++;inspector.asyncTaskScheduled(type,asyncId,recurring);},before(asyncId){cov_ygobsuc9c.s[9]++;inspector.asyncTaskStarted(asyncId);},after(asyncId){cov_ygobsuc9c.s[10]++;inspector.asyncTaskFinished(asyncId);},destroy(asyncId){cov_ygobsuc9c.s[11]++;inspector.asyncTaskCanceled(asyncId);}}));function enable(){cov_ygobsuc9c.f[1]++;cov_ygobsuc9c.s[12]++;if(config.bits<64){cov_ygobsuc9c.b[2][0]++;cov_ygobsuc9c.s[13]++;// V8 Inspector stores task ids as (void*) pointers.
// async_hooks store ids as 64bit numbers.
// As a result, we cannot reliably translate async_hook ids to V8 async_task
// ids on 32bit platforms.
process.emitWarning('Warning: Async stack traces in debugger are not available '+`on ${config.bits}bit platforms. The feature is disabled.`,{code:'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'});}else{cov_ygobsuc9c.b[2][1]++;cov_ygobsuc9c.s[14]++;hook.enable();}}function disable(){cov_ygobsuc9c.f[2]++;cov_ygobsuc9c.s[15]++;hook.disable();}cov_ygobsuc9c.s[16]++;exports.setup=function(){cov_ygobsuc9c.f[3]++;cov_ygobsuc9c.s[17]++;inspector.registerAsyncHook(enable,disable);cov_ygobsuc9c.s[18]++;if(inspector.isEnabled()){cov_ygobsuc9c.b[3][0]++;cov_ygobsuc9c.s[19]++;// If the inspector was already enabled via --inspect or --inspect-brk,
// the we need to enable the async hook immediately at startup.
enable();}else{cov_ygobsuc9c.b[3][1]++;}};