{
  "idlharness-shadowrealm.window.js": {
    "skip": "ShadowRealm support is not enabled"
  },
  "piping/general-addition.any.js": {
    "fail": {
      "note": "Blocked on https://github.com/whatwg/streams/issues/1243",
      "expected": [
        "enqueue() must not synchronously call write algorithm"
      ]
    }
  },
  "queuing-strategies-size-function-per-global.window.js": {
    "skip": "Browser-specific test"
  },
  "readable-byte-streams/read-min.any.js": {
    "fail": {
      "expected": [
        "ReadableStream with byte source: read({ min }) rejects if min is 0",
        "ReadableStream with byte source: read({ min }) rejects if min is negative",
        "ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint8Array)",
        "ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint16Array)",
        "ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (DataView)",
        "ReadableStream with byte source: read({ min }), then read()",
        "ReadableStream with byte source: read({ min }) with a DataView",
        "ReadableStream with byte source: enqueue(), then read({ min })",
        "ReadableStream with byte source: read({ min: 3 }) on a 3-byte Uint8Array, then multiple enqueue() up to 3 bytes",
        "ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 3 bytes",
        "ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 4 bytes",
        "ReadableStream with byte source: read({ min }) when closed before view is filled",
        "ReadableStream with byte source: read({ min }) when closed immediately after view is filled",
        "ReadableStream with byte source: cancel() with partially filled pending read({ min }) request",
        "ReadableStream with byte source: 3 byte enqueue(), then close(), then read({ min }) with 2-element Uint16Array must fail",
        "ReadableStream with byte source: read({ min }) with 2-element Uint16Array, then 3 byte enqueue(), then close() must fail",
        "ReadableStream with byte source: tee() with read({ min }) from branch1 and read() from branch2"
      ]
    }
  },
  "readable-streams/cross-realm-crash.window.js": {
    "skip": "Browser-specific test"
  },
  "readable-streams/owning-type-message-port.any.js": {
    "fail": {
      "note": "Readable streams with type owning are not yet supported",
      "expected": [
        "Transferred MessageChannel works as expected",
        "Second branch of owning ReadableStream tee should end up into errors with transfer only values"
      ]
    }
  },
  "readable-streams/owning-type-video-frame.any.js": {
    "skip": "Browser-specific test"
  },
  "readable-streams/owning-type.any.js": {
    "fail": {
      "note": "Readable streams with type owning are not yet supported",
      "expected": [
        "ReadableStream can be constructed with owning type",
        "ReadableStream of type owning should call start with a ReadableStreamDefaultController",
        "ReadableStream should be able to call enqueue with an empty transfer list",
        "ReadableStream should check transfer parameter",
        "ReadableStream of type owning should transfer enqueued chunks"
      ]
    }
  },
  "transferable/deserialize-error.window.js": {
    "skip": "Browser-specific test"
  },
  "transferable/transfer-with-messageport.window.js": {
    "skip": "Browser-specific test"
  },
  "transferable/transform-stream-members.any.js": {
    "fail": {
      "expected": [
        "Transferring [object TransformStream],[object ReadableStream] should fail",
        "Transferring [object TransformStream],[object WritableStream] should fail"
      ]
    }
  },
  "transform-streams/invalid-realm.tentative.window.js": {
    "skip": "Browser-specific test"
  },
  "readable-streams/read-task-handling.window.js": {
    "skip": "Browser-specific test"
  }
}
